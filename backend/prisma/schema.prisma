generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          Int     @id @default(autoincrement())
  firebaseUid String? @unique
  email       String? @unique
  displayName String?
  photoURL    String?

  // Onboarding data
  age                 Int?
  gender              String? // "male", "female", "nonbinary", "prefer_not"
  height              Float?
  weight              Float?
  units               String  @default("metric")
  bmi                 Float?
  activityLevel       String  @default("moderately_active")
  onboardingCompleted Boolean @default(false)

  // User preferences stored as JSON
  medicalRestrictions Json?
  nutritionGoals      Json?
  lifestyleDiets      Json?
  culturalDiets       Json?
  budget              Json?
  goals               Json?
  cookingLevel        String?

  // Grocery lists
  groceryLists GroceryList[]

  // Timestamps and counters
  lastLogin           DateTime @default(now())
  planGenerationCount Int      @default(0)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relations
  favorites Favorite[]
  mealPlans MealPlan[]
}

// Removed Profile model - all data now in User model directly

model Recipe {
  id                      Int            @id @default(autoincrement())
  externalId              String?        @unique
  title                   String
  description             String?
  imageUrl                String?
  mealType                String?
  totalTime               Int?
  estimatedCostPerServing Float?
  nutritionInfo           Json?
  ingredients             Json? // simple stored array for demo; normalize later if desired
  instructions            Json?
  dietaryTags             String[]       @default([])
  favorites               Favorite[]
  mealPlanItems           MealPlanItem[]
  createdAt               DateTime       @default(now())
  updatedAt               DateTime       @updatedAt
}

model Favorite {
  userId    Int
  recipeId  Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipe    Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@id([userId, recipeId])
}

model MealPlan {
  id        Int            @id @default(autoincrement())
  userId    Int
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  startDate DateTime // Start of the week (e.g., Monday)
  endDate   DateTime // End of the week (e.g., Sunday)
  items     MealPlanItem[]
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  groceryLists GroceryList[]

  @@unique([userId, startDate]) // One meal plan per user per week
}

model MealPlanItem {
  id         Int      @id @default(autoincrement())
  mealPlanId Int
  recipeId   Int
  mealPlan   MealPlan @relation(fields: [mealPlanId], references: [id], onDelete: Cascade)
  recipe     Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  date       DateTime // Specific date for this meal (YYYY-MM-DD)
  mealType   String // "breakfast", "lunch", "dinner", "snacks"
  createdAt  DateTime @default(now())

  @@unique([mealPlanId, date, mealType]) // Prevent duplicates
}

model GroceryList {
  id        String   @id @default(cuid())
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  userId   Int
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  mealPlanId Int?
  mealPlan   MealPlan? @relation(fields: [mealPlanId], references: [id], onDelete: SetNull)
  
  items GroceryItem[]
}

model GroceryItem {
  id       String  @id @default(cuid())
  name     String
  quantity String  // e.g., "2 cups", "1 lb", "3 pieces"
  source   String? // e.g., recipe name or manual entry
  checked  Boolean @default(false) // for checking off items
  
  // Relations
  groceryListId String
  groceryList   GroceryList @relation(fields: [groceryListId], references: [id], onDelete: Cascade)
}
